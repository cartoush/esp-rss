use anyhow::Result;
use display_interface_spi::{SPIInterface};
use embedded_graphics::{
    mono_font::{iso_8859_16::FONT_9X18_BOLD, MonoTextStyle},
    pixelcolor::Rgb565,
    prelude::{Dimensions, Point, RgbColor, Size},
    primitives::{Primitive, PrimitiveStyleBuilder, Rectangle},
    text::Text,
    Drawable, Pixel, iterator::pixel,
};
use embedded_svc::http::client::Client;
use esp_idf_sys::{self as _};
use lvgl::{DrawBuffer, style::Style, Color, Part, Align, widgets::{Label, Arc}, Widget};
use serde::de::IntoDeserializer;

use std::{error::Error, ffi::CString, time::Instant};
use std::thread::sleep;
use std::time::Duration;

use esp_idf_hal::{delay, gpio::AnyIOPin, gpio::PinDriver, i2c, prelude::*, spi};
use esp_idf_svc::http::client::*;

use mipidsi::*;

use log::info;

mod freshrss;
mod serde_rss;
mod wifi;

const SCR_WIDTH : u16 = 320;
const SCR_HEIGHT : u16 = 240;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("")]
    rss_domain: &'static str,
    #[default("")]
    rss_username: &'static str,
    #[default("")]
    rss_password: &'static str,
}

fn main() -> Result<(), Box<dyn Error>> {
    esp_idf_sys::link_patches();

    unsafe {
        esp_idf_sys::nvs_flash_init();

        // Disable IDLE task WatchDogTask on this CPU.
        esp_idf_sys::esp_task_wdt_delete(esp_idf_sys::xTaskGetIdleTaskHandleForCPU(
            esp_idf_hal::cpu::core() as u32,
        ));

        // Enable WatchDogTask on the main (=this) task.
        esp_idf_sys::esp_task_wdt_delete(esp_idf_sys::xTaskGetCurrentTaskHandle());
        let ret = esp_idf_sys::esp_task_wdt_status(esp_idf_sys::xTaskGetCurrentTaskHandle());
        info!("ret : {:?}", ret);
        esp_idf_sys::esp_task_wdt_delete(esp_idf_sys::xTaskGetIdleTaskHandle());
        let ret = esp_idf_sys::esp_task_wdt_status(esp_idf_sys::xTaskGetIdleTaskHandle());
        info!("ret : {:?}", ret);
    };

    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = esp_idf_svc::eventloop::EspSystemEventLoop::take()?;

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    let my_spi = spi::SpiDeviceDriver::new_single(
        peripherals.spi2,
        peripherals.pins.gpio14,
        peripherals.pins.gpio13,
        Some(peripherals.pins.gpio12),
        Option::<AnyIOPin>::None,
        &spi::SpiDriverConfig::new(),
        &spi::SpiConfig::new(),
    )?;

    // create a DisplayInterface from SPI and DC pin, with no manual CS control
    let di = SPIInterface::new(
        my_spi,
        PinDriver::output(peripherals.pins.gpio16)?,
        PinDriver::output(peripherals.pins.gpio15)?,
    );

    let mut display = Builder::ili9341_rgb565(di)
        .with_display_size(SCR_WIDTH, SCR_HEIGHT)
        .with_orientation(Orientation::Landscape(false))
        .init(
            &mut delay::Ets,
            Some(PinDriver::output(peripherals.pins.gpio17)?),
        )
        .map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;

    Rectangle::new(
        display.bounding_box().top_left,
        Size::new(
            display.bounding_box().size.height,
            display.bounding_box().size.width,
        ),
    )
    .into_styled(
        PrimitiveStyleBuilder::new()
            .fill_color(Rgb565::RED)
            .stroke_color(Rgb565::RED)
            .stroke_width(1)
            .build(),
    )
    .draw(&mut display)
    .map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;

    let style = MonoTextStyle::new(&FONT_9X18_BOLD, Rgb565::BLACK);
    Text::new("Hello Rust le monde!", Point::new(20, 30), style)
        .draw(&mut display)
        .map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;


    let mut my_i2c = i2c::I2cDriver::new(
        peripherals.i2c1,
        peripherals.pins.gpio22,
        peripherals.pins.gpio21,
        &i2c::I2cConfig::default(),
    )?;
    let mut pin5 = PinDriver::input(peripherals.pins.gpio5)?;
    PinDriver::enable_interrupt(&mut pin5)?;
    let mut touch = ft6x06::Ft6X06::new(&my_i2c, 0x38, pin5)?;

    // let mut touch = ft6x06::Ft6x06Spi::new(
    //     &my_spi,
    //     PinDriver::output(peripherals.pins.gpio18)?,
    //     PinDriver::input(peripherals.pins.gpio5)?,
    // )?;

    // Connect to the Wi-Fi network
    // let _wifi = wifi::wifi(
    //     app_config.wifi_ssid,
    //     app_config.wifi_psk,
    //     peripherals.modem,
    //     sysloop,
    // )?;

    // let conn = EspHttpConnection::new(&Configuration {
    //     use_global_ca_store: true,
    //     crt_bundle_attach: Some(esp_idf_sys::esp_crt_bundle_attach),
    //     ..Default::default()
    // })?;
    // let mut cli = Client::wrap(conn);

    // let auth_string = freshrss::freshrss_connect(
    //     &mut cli,
    //     app_config.rss_domain,
    //     app_config.rss_username,
    //     app_config.rss_password,
    // )?;

    // let str_articles =
    //     freshrss::freshrss_get_articles(&mut cli, &auth_string, app_config.rss_domain)?;
    // let articles: serde_rss::RssReadingList = serde_json::from_str(str_articles.as_str())?;

    // info!("articles : {:?}", articles);

    let ret = touch.chip_id(&mut my_i2c)?;
    info!("chip id : {:?}", ret);


    let buffer = DrawBuffer::<{ (SCR_WIDTH as usize * SCR_HEIGHT as usize) as usize }>::default();
    let lvgl_display = lvgl::Display::register(buffer, SCR_WIDTH as u32, SCR_HEIGHT as u32, |refresh| {
        let pixels = refresh.colors.map(|pix| Rgb565::new(pix.r(), pix.g(), pix.b()));
        display.set_pixels(0, 0, SCR_WIDTH, SCR_HEIGHT, pixels).map_err(
            |e| anyhow::anyhow!("Display error : {:?}", e)).expect("Error happened");
    }).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;

    let mut screen = lvgl_display.get_scr_act().map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;

    // let mut screen_style = Style::default();
    // screen_style.set_bg_color(Color::from_rgb((255, 255, 255)));
    // screen_style.set_radius(0);
    // screen.add_style(Part::Main, &mut screen_style).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;

    // // Create the arc object
    // let mut arc = Arc::create(&mut screen).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;
    // arc.set_size(150, 150).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;
    // arc.set_align(Align::Center, 0, 10).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;
    // arc.set_start_angle(135).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;
    // arc.set_end_angle(135).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;

    // let mut loading_lbl = Label::create(&mut screen).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;
    // loading_lbl.set_align(Align::OutTopMid, 0, 0).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;
    // //loading_lbl.set_label_align(LabelAlign::Center)?;

    // let mut loading_style = Style::default();
    // loading_style.set_text_color(Color::from_rgb((0, 0, 0)));
    // loading_lbl.add_style(Part::Main, &mut loading_style).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?;

    // let mut angle = 0;
    // let mut forward = true;
    // let mut i = 0;

    loop {
        let is_touched = touch
            .td_status(&mut my_i2c)
            .expect("is_touched fail");
        if is_touched > 0 && is_touched != 255 {
            // returns (y, x)
            let pos = touch.get_coordinates(&mut my_i2c)?;
            info!("touch coordinates : {:?}", pos);
            if pos.0 > SCR_HEIGHT || pos.1 > SCR_WIDTH {
                info!("pos fucked : {:?}", pos);
                continue;
            }
            Pixel(Point::new((SCR_WIDTH - pos.1).into(), pos.0.into()), Rgb565::GREEN).draw(&mut display).map_err(|e| anyhow::anyhow!("Display error : {:?}", e))?
        }
        sleep(Duration::from_millis(10));
    }
}
